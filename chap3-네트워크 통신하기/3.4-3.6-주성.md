## 3.4 TCP와 UDP

- 실제 서비스는 경로를 찾는 것이 끝이 아니라 애플리케이션이 정상적으로 돌아가기 위한 다양한 작업에 문제가 없어야 함

### 3.4.1 4계층 프로토콜(TCP, UDP)과 서비스 포트

- 인(디)캡슐레이션 과정에 각 계층에서 정의하는 헤더가 추가되고 다양한 정보가 들어감

  - **`각 계층에서 정의하는 정보`** : 수신 측의 동일 계층에서 **사용하기 위한 정보**

    - 예시) 2계층 MAC 주소, 3계층 IP주소, 4계층 시퀀스 번호 및 ACK 번호 
  
  - **`상위 프로토콜 지시자 정보`** : 디캡슐레이션 과정에서 상위 계층의 프로토콜이나 프로세스를 **정확히 찾아가기 위한 목적**

    - 예시) 2계층 이더 타입, 3계층 프로토콜 번호, 4계층 포트 번호

![image](https://github.com/Deep-Dive-Study/network-for-engineer/assets/99165624/fb1bb705-6636-49ec-8d34-a77a49f42b0c)

- **`4계층의 목적`**

  - 애플리케이션에서 사용하는 **프로세스를 정확히 찾아** 가고 데이터를 분할한 **패킷을 잘 쪼개 보내고 잘 조립하는 것**
  
    - 패킷을 분할하고 조합하기 위해 `시퀀스 번호`와 `ACK 번호`를 사용
    
- `4계층 상위 프로토콜 지시자` : **`포트 번호`** → 출발지와 목적지를 구분해 처리
  - 평소 표현하는 포트는 서버의 포트를 의미함

  - 응답시에 요청 포트와 응답 포트가 반대가 됨

![image](https://github.com/Deep-Dive-Study/network-for-engineer/assets/99165624/d10e7674-fbea-467f-b289-84c57e45936a)

- `웰 노운(Well Known) 포트` : HTTP TCP 80, HTTPS TCP 443, SMTP TCP 25 등 **잘 알려진 포트** (1023번 이하)

  - 등록된(Registered) 포트 : 1024 ~ 49151의 범위의 포트, IANA에 등록해서 사용
    - 공식, 비공식 번호가 혼재되어 있고 사설 포트로 사용되기도 함

  - 동적(Dynamic) 포트 : 사설, 임시 포트라고도 불림, 49152 ~ 65535의 범위를 가짐
    - 자동 할당되거나 사설 용도, 클라이언트의 임시 포트로 사용 

![image](https://github.com/Deep-Dive-Study/network-for-engineer/assets/99165624/5f754545-8a02-4f31-bf68-01acd81cc7f9)

- 생각해볼 점: 사용자(클라이언트) 포트가 겹치면 어떻게 될까?

- 참고: https://youtu.be/X73Jl2nsqiE

### 3.4.2 TCP

- 신뢰할 수 없는 공용망에서도 정보유실 없는 통신을 보장하기 위해 세션을 `안전하게 연결`하고 `데이터를 분할`하고 `분할된 패킷이 잘 전송되었는지 확인`하는 기능

- `패킷에 번호(Sequence Number)`를 부여하고 잘 전송되었는지에 대해 `응답(Acknowledge Number)`함

- 한꺼번에 얼마나 보내야 수신자가 잘 받아 처리할 수 있는지 `전송 크기(Window Size)`까지 고려해서 통신함

#### 3.4.2.1 패킷 순서, 응답 번호

- 패킷을 잘 분할하고 수신 측이 잘 조합하도록 패킷에 순서를 주고 응답 번호 부여
  
  - `시퀀스 번호` : 패킷에 순서를 부여하는 것
    
  - `ACK 번호` : 응답 번호를 부여하는 것

  - 두 번호의 상호작용을 통해 순서가 바뀌거나 패킷이 손실된 것을 파악

![image](https://github.com/Deep-Dive-Study/network-for-engineer/assets/99165624/5ceb7b97-4059-4928-a82f-7107ea55e77f)

- 보내는 쪽에서 패킷에 번호를 부여 → 받는 쪽은에서 번호의 순서가 맞는지 확인

- 번호가 맞으면 응답함(**`다음 번호의 패킷을 요청`**)
  - 송신 1번 전송 → 수신측 2번 ACK 전송

![image](https://github.com/Deep-Dive-Study/network-for-engineer/assets/99165624/976e7055-bd5f-492b-8fdd-a14bcdd0f3b0)

#### 3.4.2.2 윈도 사이즈와 슬라이딩 윈도

- TCP는 패킷을 보내고 잘 전송되었는지 확인하기 위해 별도의 패킷을 받기 때문에 통신이 오래 걸림
  - 먼 거리 일수록 RTT(Round Trip Time)가 늘어나기 때문에 응답을 기다리는 시간이 더 길어짐 

- 따라서, 데이터를 보낼 때 많은 패킷을 한꺼번에 보내고 응답은 하나만 받음

![image](https://github.com/Deep-Dive-Study/network-for-engineer/assets/99165624/21638acf-fd73-4532-b49b-089ebfdca6d8)

- 최대한 많은 패킷을 보내는 것이 좋지만 네트워크 상태가 안좋으면 패킷 유실 가능성이 커지므로 **`적절한 송신량`** 을 정해야 함

  - **`윈도 사이즈`** : 한 번에 데이터를 받을 수 있는 데이터 크기
  
  - **`슬라이딩 윈도`** : 네트워크 상황에 따라 윈도 사이즈를 조절하는 것

- TCP는 데이터에 유실이 발생하면 윈도 사이즈를 절반으로 떨어뜨리고 정상적인 통신이 되는 경우 서서히 늘리는 방식
  - 네트워크 경합으로 인해 윈도우 사이즈가 작아질 수 있음
    - 데이터 통신 속도가 느려짐 → 회선을 제대로 사용하지 못하는 상황

  - **경합을 피하기 위한 방법**
    - 회선 속도를 증가시키기
    - 경합을 임시로 피할 수 있는 버퍼가 큰 네트워크 장비 사용
    - TCP 최적화 솔루션 사용

#### 3.4.2.3 3방향(Way) 핸드셰이크

- 통신 전, **`데이터를 안전하게 보내고 받을 수 있는지 미리 확인하는 작업`**

  - 통신에 필요한 리소스를 미리 확보
  
  - 3번의 패킷을 주고받으면서 통신을 서로 준비

![image](https://github.com/Deep-Dive-Study/network-for-engineer/assets/99165624/aed64032-3f9d-4a48-a611-0767fd4b2614)

**`진행 상황에 따른 상태 정보`**

- `LISTEN 상태` : 서버에서 서비스를 제공하기 위해 클라이언트의 접속을 받아들일 수 있는 상태

- `SYN-SENT 상태` : 클라이언트에서 통신을 시도할 때 SYN 패킷을 보냄
  
- `SYN-RECEIVE 상태` : 클라이언트의 SYN을 받은 서버, SYN, ACK로 응답
  
- `ESTABLISHED 상태` : 응답을 받은 클라이언트, 그에 대한 응답을 서버로 다시 보냄 → 서버도 해당 상태로 변경
  - → 서버와 클라이언트 간의 연결이 성공적으로 완료

- **`플래그`** : 어떤 패킷이 새로운 연결 시도이고 기존 통신에 대한 응답인지 구분하기 위한 헤더 값

  - 총 6가지 : 초기 연결, 응답, 정상 종료, 비정상 종료, 등  
  
    - `SYN` : 연결 시작 용도, 연결 시작시 SYN 플래그에 1로 표시
      
    - `ACK` : ACK 번호 유효 시 1로 표시, 초기 SYN이 아닌 모든 패킷은 기존 메시지에 대한 응답(1로 표기)
      
    - `FIN` : 연결 종료 시 1로 표시, 정상적으로 양방향 종료 시 사용
      
    - `RST` : 연결 종료 시 1로 표시, 연결을 일방적으로 끊을 때 사용
      
    - `URG` : 긴급 데이터, 1로 표시
      
    - `PSH` : 서버 측에서 전송할 데이터가 없을 때, 데이터를 버퍼링 없이 응용 프로그램으로 즉시 전달할 때

![image](https://github.com/Deep-Dive-Study/network-for-engineer/assets/99165624/1c3989fa-ae67-4007-8f40-0a1631ded2d5)

**`3-Way Handshake 과정`**

![image](https://github.com/Deep-Dive-Study/network-for-engineer/assets/99165624/4fb74815-bd06-4850-84d3-8f096efa609a)

### 3.4.3 UDP

- 4계층이 가져야할 특징이 거의 없음

![image](https://github.com/Deep-Dive-Study/network-for-engineer/assets/99165624/a160b8b9-d920-4b9f-a241-97c29566d128)

- 데이터 전송을 보장하지 않는 프로토콜 → 제한된 용도로만 사용

  - 음성 데이터, 실시간 스트리밍과 같이 시간에 민감한 경우
 
  - 신뢰성보다 일부 데이터가 유실되더라도 시간에 맞추어 계속 전송하는 것이 중요한 경우 

  - 사내 방송, 증권 시세 데이터 전송과 같이 단방향으로 다수의 단말과 통신해 응답을 받기 어려운 환경

- 중간에 데이터가 일부 유실되더라도 그냥 유실된 상태로 데이터 처리함
  
- 사전에 연결을 확립하는 절차 X, 대신 첫 데이터는 리소스 확보를 위해 인터럽트를 거는 용도로 사용되고 유실

**`참고`**

- 일반적으로 연결은 TCP로 하고 실제 데이터에서 UDP를 활용함

- 실시간 아닌 유튜브, 넷플릭스 같은 경우 TCP 사용함. 원활한 시청을 위해 영상을 미리 받아 캐시에 저장 

**`TCP와 UDP 특징 비교 및 정리`**

![image](https://github.com/Deep-Dive-Study/network-for-engineer/assets/99165624/005e49d9-bd89-43a5-9c7d-c10f438c1413)

## 3.5 ARP(Address Resolution Protocol)

- **`상대방의 MAC 주소를 알아내기 위해 사용되는 프로토콜`**

- IP주소를 MAC 주소로 변환(`물리적 주소와 논리적 주소를 연결`)

### 3.5.1 ARP란?

- IP 주소 체계는 물리적 MAC 주소와 전혀 연관성이 없으므로 두 개의 주소를 연계시켜 주기 위한 메커니즘 필요
    - 통신할 때 상대방의 MAC 주소를 알아야 함(캡슐화하기 위해)

- ARP 브로드캐스트를 받은 목적지는 ARP 프로토콜을 이용해 자신의 MAC 주소 응답
    - 출발지, 목적지 서로 상대에 대한 MAC 주소를 학습하게 됨

- ARP 브로드 캐스트는 네트워크 통신에 많은 부하를 주기 때문에 메모리에 저장해두고 재사용함(ARP 캐시, ARP 테이블)
    - 논리 주소가 언제든 변할 가능성이 있기 때문에 일정 시간 통신이 없으면 테이블은 삭제됨

- ARP 테이블 저장 기간을 일반 PC보다 길게 설정하고 많은 ARP 요청이 들어오면 이를 필터링하거나 천천히 처리하는 방식으로 장비를 보호
    - 네트워크 공격에 의한 부하 방지

    - ARP 테이블을 수동으로만 갱신하도록 설정하기도 함

### 3.5.2 ARP 동작

![image](https://github.com/Deep-Dive-Study/network-for-engineer/assets/99165624/e35099f0-06a1-4000-9303-757c2d209e38)

- 송신자 하드웨어 MAC 주소, 송신자 IP 프로토콜 주소, 대상자 MAC 주소, 대상자 IP 프로토콜 주소

![image](https://github.com/Deep-Dive-Study/network-for-engineer/assets/99165624/9396bc0e-c679-4ef9-b487-713a823161b8)

- 캡슐화하기 위해서는 MAC 주소를 알아야 함

- ARP 요청을 처음 보낼 때 : 브로드캐스트
    - 출발지는 자신의 MAC, 도착지는 브로드캐스트(FF-FF-FF-FF-FF-FF)
    - 전송자 MAC과 IP는 자신의 주소, 대상자 IP 상대방 IP로 대상자 MAC은 00-00-00-00-00-00으로 설정

![image](https://github.com/Deep-Dive-Study/network-for-engineer/assets/99165624/2134aff8-3839-4118-b907-bbbaee9eb799)

- ARP 응답을 보낼 때 : 출발지와 도착지 MAC 주소가 명시되어 있는 유니캐스트

![image](https://github.com/Deep-Dive-Study/network-for-engineer/assets/99165624/d2a09851-8597-4186-b2d6-8cb3cad1a46e)

- ARP 캐시 테이블을 갱신함
    - 정해진 시간 동안 유지
    - 해당 시간 안에 통신이 이루어지면 시간 초기화

![image](https://github.com/Deep-Dive-Study/network-for-engineer/assets/99165624/6e5d4844-f162-412d-9c0f-63d7cefe728b)

### 3.5.3 GARP(Gratuitous ARP)

- **ARP 프로토콜 필드를 그대로 사용하지만 내용을 변경해 원래 ARP 프로토콜의 목적과 다른 용도로 사용**

- `대상자 IP 필드에 자신의 IP 주소를 채워 ARP 요청 보냄`

- `로컬 네트워크에 자신의 IP와 MAC 주소를 알릴 목적으로 사용`

- 패킷 분석
    - 목적지 MAC 주소(2계층 Destination MAC)는 브로드캐스트 MAC 주소 사용

    - 송신자 MAC(Sender MAC) : 자신의 MAC 주소

    - 송신자 IP(Sender IP) : 자신의 IP 주소

    - 대상자 MAC(Target MAC) : 모두 0, 00:00:00:00:00:00

    - 대상자 IP(Target IP) : 자신의 IP 주소 - 이부분이 일반 ARP와 다름

- GARP를 사용해 네트워크에 자신의 주소를 알려주는 이유
    - IP 주소 충돌 감지
    - 상대방(동일 서브넷에 있는)의 ARP 테이블 갱신
    - HA(High Availability-고가용성) 용도의 클러스터링, VRRP, HSRP

#### 3.5.3.1 IP 주소 충돌 감지

- `IP가 네트워크에서 이미 사용되고 있는지 GARP를 통해 확인`
    - 여러 이유로 내가 할당 받은 IP 주소를 다른 사람이 사용하고 있을 수 있음

    - IP 충돌 때문에 통신이 안되는 것을 예방하기 위해 사용

- GARP에 대한 응답 → 네트워크상에서 해당 IP를 이미 사용 중

#### 3.5.3.2 상대방(동일 서브넷에 있는)의 ARP 테이블 갱신

- 가상 MAC 주소를 사용하지 않는 데이터베이스 HA 솔루션에서 주로 사용

- HA 데이터베이스는 주로 두 대의 데이터베이스 서버가 하나의 가상 IP 주소로 서비스 함
    - 두 대의 데이터베이스 중 한 대만 동작하고 나머지 한 대는 대기하는 액티브-스탠바이(Active-Standby)로 동작

![image](https://github.com/Deep-Dive-Study/network-for-engineer/assets/99165624/01bdaa04-d0c1-408f-a652-7c31312da536)

- 액티브 상태인 서버가 가상 IP 주소 요청에 응답해 서비스 하지만 MAC 주소는 가상 주소가 아닌 실제 MAC 주소를 사용하고 있음

- 따라서, `스탠바이 장비가 액티브 상태가 되면 GARP 패킷을 네트워크에 보내 액티브 장비가 변경되었음을 알려주어야 함`

- 최근에는 운영상, 보안상의 이유(탈취되는 경우)가 있어서 이러한 형태는 잘 사용하지 않고 가상의 MAC을 사용하는 HA 솔루션을 사용함

#### 3.5.3.3 클러스터링, FHRP(VRRP, HSRP)

![image](https://github.com/Deep-Dive-Study/network-for-engineer/assets/99165624/1fe5f1d2-e6c2-4253-83ac-42f8ec8cd2d9)

- 장비 이중화를 위해 사용되지만 실제 MAC 주소를 사용하지 않고 가상 MAC을 사용하는 클러스터링, VRRP, HSRP와 같은 FHRP(First Hop Redundancy Protocol)에서도 사용

- 위의 경우에는 단말의 ARP 테이블을 갱신하는 것이 목적이었던 반면, 해당 경우는 `네트워크에 있는 스위치 장비의 MAC 테이블 갱신 목적`

- 슬레이브가 마스터로 역할이 변경 → GARP 전송, 스위치에서는 GARP를 통해 MAC 주소에 대한 포트 정보를 새로 변경 후 MAC 테이블 갱신

![image](https://github.com/Deep-Dive-Study/network-for-engineer/assets/99165624/574402b1-2c47-4242-a669-7b43a83c7485)

![image](https://github.com/Deep-Dive-Study/network-for-engineer/assets/99165624/8e50b8f3-e671-42d6-816c-4b833b693398)

### 3.5.4 RARP(Reverse ARP)

- 반대로 동작하는 ARP

- ARP 프로토콜 구조는 같지만 필드에 들어가는 내용이 다르고 원래 목적과 반대로 사용

- IP 주소가 정해져 있지 않은 단말이 IP 할당을 요청할 때 사용

- 자신의 MAC 주소는 알지만 IP가 아직 할당되지 않아 IP를 할당해주는 서버에 어떤 IP 주소를 써야 하는지 물어볼 때 사용

- BOOTP와 DHCP로 대체되어 현재는 사용하지 않음

## 3.6 서브넷과 게이트웨이

- 인터넷의 발달로 다른 LAN 간의 통신이 중요해짐

- **동일 네트워크 통신** 과 **원격지 네트워크 간 통신** 은 동작 방식이나 필요한 네트워크 장비가 다름

### 3.6.1 서브넷과 게이트웨이의 용도

- **`게이트웨이(Gateway)`** : 원격 네트워크 통신은 네트워크를 넘어 전달되지 못하는 브로드캐스트의 성질 때문에 네트워크 장비의 도움 필요

![image](https://github.com/Deep-Dive-Study/network-for-engineer/assets/99165624/ef3b46e7-279a-445d-9fe4-2d2b682ac162)

- `기본 게이트웨이(Default Gateway)` : 게이트웨이에 대한 정보를 PC나 네트워크 장비에 설정하는 항목

  - 3계층 장비가 수행함

  - 여러 네트워크와 연결되면서 적절한 경로를 지정해주는 역할
    
![image](https://github.com/Deep-Dive-Study/network-for-engineer/assets/99165624/8bad76d7-7b8a-44a8-92f6-e7ab2c7c029a)

- 출발지에서는 먼저 목적지가 자신이 속한 네트워크의 범위인지 확인하는 작업 필요

  - `서브넷 마스크` : 동일 네트워크 간의 통신과 서로 다른 네트워크 간의 통신을 구분

  - 동일한 네트워크 주소하면 로컬 통신 아니면 원격지 통신 

  - 서브넷 마스크를 통해 로컬 네트워크 주소 파악 후, 로컬 네트워크라면 ARP를 통해 대상자의 MAC 주소를 알아내고, 원격지 네트워크라면 기본 게이트웨이의 MAC 주소를 알아내야 함

#### 프록시 ARP

- ARP를 대행해주는 기능

- 프록시 ARP가 활성화된 기본 게이트웨이는 ARP 브로드캐스트가 들어오면 자신이 대행해 ARP 응답 해줌 → 원격지 경로로 전달

### 3.6.2 2계층 통신 vs 3계층 통신

- **`로컬 네트워크 통신`** vs **`원격지 네트워크 통신`**

- **`L2 통신`** : 단말 간을 연결해주는 네트워크 장비에서 2계층까지만 정보를 확인해 통신하고 ARP 요청을 보낼 때 직접 브로드캐스트 이용

- **`L3 통신`** : 원격지 네트워크와 통신해야 할 경우(출발지와 목적지가 다른 네트워크에 존재할 경우), 라우터와 같은 3계층 장비의 도움이 없으면 통신 불가

![image](https://github.com/Deep-Dive-Study/network-for-engineer/assets/99165624/cd6eac55-849b-49ee-b05b-07311e8d716d)

- 로컬과 리모트 통신을 위한 ARP 동작 방식이 다른 것으로 인해 발생

![image](https://github.com/Deep-Dive-Study/network-for-engineer/assets/99165624/1223c373-3fb8-4581-9bb1-717798cf8ad8)

- **`같은 네트워크에 있는 단말 간 통신`** : 상대방의 MAC 주소를 알아내기 위해 ARP 브로드캐스트 이용, 상대방의 MAC 주소를 알아내자마자 패킷이 캡슐화되어 통신 시작

- **`외부 네트워크와 통신`** : 단말이 자신이 직접 보낼 수 없는 위치에 목적지가 있다 판단 → ARP 요청을 기본 게이트웨이의 IP 주소로 요청 → 도착지 MAC 주소에 응답받은 기본 게이트웨이의 MAC 주소를
  적어놓고 통신 시작

![image](https://github.com/Deep-Dive-Study/network-for-engineer/assets/99165624/6ee22769-a4ea-4b31-b3cb-87e6365275dc)

- **`로컬 통신`** 은 도착지 MAC 주소와 도착지 IP 주소 동일

- **`원격지 통신`** 은 도착지 MAC 주소와 도착지 IP 주소 다름
