# 3.4~3.6장

# 3.4 TCP, UDP

4계층 프로토콜은 목적지 프로세스를 정확히 파악하고 패킷 순서가 바뀌지 않도록 잘조합하는 역할을 한다.

### TCP, UDP와 서비스 포트

# 3.4~3.6장

# 3.4 TCP, UDP

4계층 프로토콜은 목적지 프로세스를 정확히 파악하고 패킷 순서가 바뀌지 않도록 잘조합하는 역할을 한다.

### TCP, UDP와 서비스 포트

# 3.4~3.6장

# 3.4 TCP, UDP

4계층 프로토콜은 목적지 프로세스를 정확히 파악하고 패킷 순서가 바뀌지 않도록 잘조합하는 역할을 한다.

### TCP, UDP와 서비스 포트

# 3.4~3.6장

# 3.4 TCP, UDP

4계층 프로토콜은 목적지 프로세스를 정확히 파악하고 패킷 순서가 바뀌지 않도록 잘조합하는 역할을 한다.

### TCP, UDP와 서비스 포트

![image](https://github.com/Deep-Dive-Study/network-for-engineer/assets/85796588/9615dcfa-5d45-4b6c-8cba-8cb815992c75)

4계층에선 시퀀스 번호와 ACK 번호를 동일 계층에서 사용하는 정보로 사용하고, 포트 번호로 상위 프로토콜을 결정한다. 

2,3 계층에선 출발지와 도착지를 구분하지 않고 한 개만 사용했지만, 4계층의 포트 번호는 출발지와 목적지를 구분해 처리한다.(클라이언트-서버 방식)

따라서 요청에서 출발지 포트와 목적지 포트가 응답에서 반대가 된다. 이는 서비스 흐름을 이해하는데 매우 중요하다.

### TCP

TCP는 신뢰할 수 없는 공용망에서 정보 유실 없는 통신을 보장하기 위해 **세션을 안전하게 연결**하고 분할된 **패킷이 잘 전송되었는지 확인**한다.

패킷에 Sequence를 부여해 전송 여부를 응답받고, 전송 크기까지 고려한다.

분할된 패킷에 순서를 부여하고 ACK 라는 응답 번호를 통해 통신간에 패킷의 순서가 바뀌거나 손실 여부를 파악할 수 있다.

**윈도 사이즈와 슬라이딩 윈도**

패킷이 잘 전송되었는지 확인하기 위해 ACK를 받는 것 자체가 왕복 지연시간을 늘리기 때문에 여러 패킷을 한번에 보내고 응답을 하나만 받는다. 

한 번에 모든 패킷을 전송하면 좋겠지만, 네트워크 상태에 따라서 유실될 수 있기 때문에 적절한 송신량을 결정해야 하는데 이를 “윈도 사이즈”라고 하며 이 크기를 조절하는 것을 슬라이딩 윈도라고 한다.

데이터 유실이 생기면 윈도 사이즈를 절반으로 떨어트리고, 정상적으로 통신이 되면 사이즈를 하나씩 늘린다. 

윈도 사이즈는 2^16으로 64K까지 표현이 가능한데 shift 연산을 통해 그 이상의 크기 통신도 가능하다.

**3 way handshake**

TCP에서 유실없는 안전한 통신을 위해 통신 시작전 사전 연결작업을 진행한다.

1. 클라이언트에서 통신을 시도할 때 Syn 패킷을 보낸다.
2. 서버는 Syn, Ack로 응답한다.
3. 클라이언트가 Ack를 보내고 성공적으로 연결이 된다.

기존 통신과 다른점은 새로운 연결인지, 기존 통신인지 구분하기위해 헤더에 플래그값을 넣는다는 점이다.

* 4 way handshake

3 way handshake가 세션을 초기화 하기 위해 사용하는 것이면, 4 way handshake는 세션을 종료할 때 사용한다.

1. 클라이언트에서 Fin 플래그를 전송한다.
2. 서버는 Ack를 보내고 통신이 끝날때까지 기다린다.
3. 서버가 연결을 종료할 준비가 되면 Fin 플래그를 전송한다.
4. 클라이언트도 Ack 를 반환하고 세션을 종료한다.

**TCP 헤더**

- SYN - 연결 시작 용도로 사용한다.
- ACK - ACK 번호가 유효할 경우 사용한다. (SYN이 아닌이상 항상 1)
- FIN - 정상적으로 연결 종료시 1로 표시한다.
- RST - 연결 강제 종료시 사용한다.
- URG - 긴급 데이터인 경우 사용한다.
- PSH - 서버측에서 전송할 데이터가 없거나, 버퍼링없이 응용프로그램으로 즉시 전달할때 사용한다.

**정리**

- 통신 시작을 위해 3 way handshake를 통해 연결을 초기화한다.
- 패킷에 번호를 부여하고 윈도 단위로 전송한다.
- 패킷을 메모리에 유지하고, 모두 전송이 완료되야 메모리에서 제거한다.

### UDP

TCP와 다르게 4계층 프로토콜의 특징이 거의 없다. 헤더의 내용도 TCP에 비해 굉장히 가볍다.

UDP는 데이터 신뢰성을 보장하지 않는 프로토콜이므로 실시간성 프로토콜이나 단방향으로 다수의 단말과 통신하는 경우 사용된다. (실시간 스트리밍, 증권 시세 데이터)
이처럼 데이터를 전송하는데 신뢰성보다 시간에 맞추어 계속 전송하는 것이 중요한 서비스인 경우 사용하게 된다. UDP는 데이터가 일부 유실되더라도 그냥 유실된 상태로 데이터를 처리한다.

3 way handshake 처럼 연결을 확립하는 절차 없이 첫 데이터는 리소스 확보를 위해 인터럽트를 거는 용도로 사용되고 유실된다. 따라서 UDP를 사용하는 애플리케이션은 대부분 이런 상황을 인지하고 동작하거나 연결 확립을 위해 TCP 프로토콜을 사용해 준비를 마친 후 UDP를 이용하는 경우가 대부분이다.

**정리**

- 비연결형(3 way handshake 같은 과정 없음)
- 오류, 흐름제어를 하지 않는다.
- 실시간성 또는 단방향 통신에 주로 사용한다.

# 3.5 ARP(Address Resolution Protocol)

2계층의 MAC주소와 3계층의 IP는 아무 관계가 없는데, MAC주소를 어떻게 알아내서 통신할까? → ARP사용

첫 통신을 시도할때 IP는 있지만, MAC을 알 수 없어 패킷을 캡슐화 할 수 없다. 이때 ARP 브로드캐스트를 이용해 네트워크 전체에 상대방에 MAC 주소를 질의한다.

ARP 브로드캐스트를 받은 목적지는 자신의 MAC 주소를 응답하여 이후 패킷이 캡슐화되어 상대방에게 전달된다.

이때 받은 정보를 매번 요청하면 효율성이 저하되기 때문에 메모리에 저장해두고 재사용한다. IP는 변경될 수 있기 때문에 일정시간 통신이 없으면 삭제한다.

ARP는 CPU에서 직접 처리하기 때문에 ARP 요청이 몰리는 경우 큰 부하가 생긴다. 그렇기 때문에 ARP 공격을 하기도 하는데, ARP 요청을 필터링 하거나, 천천히 처리하도록 할 수 있다. ARP 캐시 외에도 DNS, 라우팅 캐시를 통해 네트워크 성능을 높인다.

### 동작 방법

서버에서 ping을 보낼 때 MAC을 알 수 없어 패킷을 캡슐화 할 수 없다. 이때 ARP 브로드캐스트를 이용해 네트워크 전체에 상대방에 MAC 주소를 질의한다.

출발지는 자신의 MAC 주소를, 도착지는 브로드캐스트로 채우고 ARP 프로토콜을 전송하는데, ARP 프로토콜의 대상자가 자신에 대한 요청이 맞는지 확인하고 그에대한 응답을 유니캐스트로 한다.

### GARP

일반 ARP 외에도 GARP, RARP 등의 프로토콜이 있다. 여기서 G는 Gratuitous의 약자로 대상자 IP 필드에 자신의 IP주소를 채워 요청을 보낸다.

기존의 ARP와 다른점은 자신의 IP와 MAC주소를 알릴 목적으로 사용되는 점이다.

그렇다면 왜 GARP를 사용하는걸까?

- IP 주소 충돌 감지
GARP에 대한 응답이 오면 네트워크에 동일한 IP를 사용하고 있는 것이다.
- 상대방의 ARP 테이블 갱신
액티브-스탠바이 동작하는 DB의 경우 IP는 같지만 MAC이 다른데, 스탠바이 상태의 DB가 액티브로 변할때 **변경된 MAC 주소를 알리기** 위해 사용된다.
- 고가용성 용도의 클러스터링, VRRP, HSRP
HA 솔루션의 경우처럼 이중화를 위해 사용하지만 가상 MAC을 사용하는 경우도 GARP를 사용한다. **스위치의 MAC 테이블 갱신**이 목적이다.

* DB에서 고가용성을 제공하는 경유 GARP를 여러번 보내 내부 단말의 ARP 테이블을 확실히 업데이트 하도록 해야한다. 최근엔 GARP를 가로챌 수 있어 가상 MAC을 사용하는 솔루션을 사용한다

### RARP

Reverse ARP의 뜻으로 필드값과 목적이 다르다. 현재는 BOOTP, DHCP로 대체되어 사용되지 않는다.

MAC주소를 알고, IP주소가 정해지지 않은 단말이 IP할당을 요청할 때 사용한다.

# 3.6 서브넷과 게이트웨이

게이트웨이 : 원격지 네트워크와의 통신에 사용하는 장비(라우터, L3 스위치)

### 용도

원격지 네트워크 통신은 ARP 브로드캐스트를 사용할 수 없기 때문에 게이트웨이의 도움이 필요한데, 게이트웨이에 대한 정보를 PC나 네트워크 장비에 설정하는 항목이 기본 게이트웨이다.

목적지가 동일 네트워크인지 먼저 판단해야 하는데 이때 사용하는 것이 서브넷 마스크다.

**기본 게이트웨이**

3계층 장비가 수행하는데, 여러 네트워크와 연결될 때  적절한 경로를 지정해주는 역할이다.

**프록시 ARP**

게이트웨이에 프록시 ARP가 활성화된 경우 원격지더라도 ARP 프로드캐스트를 보낼 수 있다. (장애 발생 위험이 있다.)

### 2계층 VS 3계층

2계층 통신 : 단말간 연결해주는 네트워크 장비에서 2계층까지만 정보를 확인해 통신하고 ARP 요청을 보낼때

3계층 통신 : 원격지 네트워크와 통신해야 할 경우, 해당 패킷을 전송하는 네트워크 장비에서 3계층까지 확인할 때

2계층과 3계층으로 나뉘는 기준은 출발지와 도착지의 네트워크가 같은지 유무에 따라 다른데 이는 ARP동작이 다르기 때문이다.
4계층에선 시퀀스 번호와 ACK 번호를 동일 계층에서 사용하는 정보로 사용하고, 포트 번호로 상위 프로토콜을 결정한다. 

2,3 계층에선 출발지와 도착지를 구분하지 않고 한 개만 사용했지만, 4계층의 포트 번호는 출발지와 목적지를 구분해 처리한다.(클라이언트-서버 방식)

따라서 요청에서 출발지 포트와 목적지 포트가 응답에서 반대가 된다. 이는 서비스 흐름을 이해하는데 매우 중요하다.

### TCP

TCP는 신뢰할 수 없는 공용망에서 정보 유실 없는 통신을 보장하기 위해 **세션을 안전하게 연결**하고 분할된 **패킷이 잘 전송되었는지 확인**한다.

패킷에 Sequence를 부여해 전송 여부를 응답받고, 전송 크기까지 고려한다.

분할된 패킷에 순서를 부여하고 ACK 라는 응답 번호를 통해 통신간에 패킷의 순서가 바뀌거나 손실 여부를 파악할 수 있다.

**윈도 사이즈와 슬라이딩 윈도**

패킷이 잘 전송되었는지 확인하기 위해 ACK를 받는 것 자체가 왕복 지연시간을 늘리기 때문에 여러 패킷을 한번에 보내고 응답을 하나만 받는다. 

한 번에 모든 패킷을 전송하면 좋겠지만, 네트워크 상태에 따라서 유실될 수 있기 때문에 적절한 송신량을 결정해야 하는데 이를 “윈도 사이즈”라고 하며 이 크기를 조절하는 것을 슬라이딩 윈도라고 한다.

데이터 유실이 생기면 윈도 사이즈를 절반으로 떨어트리고, 정상적으로 통신이 되면 사이즈를 하나씩 늘린다. 

윈도 사이즈는 2^16으로 64K까지 표현이 가능한데 shift 연산을 통해 그 이상의 크기 통신도 가능하다.

**3 way handshake**

TCP에서 유실없는 안전한 통신을 위해 통신 시작전 사전 연결작업을 진행한다.

1. 클라이언트에서 통신을 시도할 때 Syn 패킷을 보낸다.
2. 서버는 Syn, Ack로 응답한다.
3. 클라이언트가 Ack를 보내고 성공적으로 연결이 된다.

기존 통신과 다른점은 새로운 연결인지, 기존 통신인지 구분하기위해 헤더에 플래그값을 넣는다는 점이다.

* 4 way handshake

3 way handshake가 세션을 초기화 하기 위해 사용하는 것이면, 4 way handshake는 세션을 종료할 때 사용한다.

1. 클라이언트에서 Fin 플래그를 전송한다.
2. 서버는 Ack를 보내고 통신이 끝날때까지 기다린다.
3. 서버가 연결을 종료할 준비가 되면 Fin 플래그를 전송한다.
4. 클라이언트도 Ack 를 반환하고 세션을 종료한다.

**TCP 헤더**

- SYN - 연결 시작 용도로 사용한다.
- ACK - ACK 번호가 유효할 경우 사용한다. (SYN이 아닌이상 항상 1)
- FIN - 정상적으로 연결 종료시 1로 표시한다.
- RST - 연결 강제 종료시 사용한다.
- URG - 긴급 데이터인 경우 사용한다.
- PSH - 서버측에서 전송할 데이터가 없거나, 버퍼링없이 응용프로그램으로 즉시 전달할때 사용한다.

**정리**

- 통신 시작을 위해 3 way handshake를 통해 연결을 초기화한다.
- 패킷에 번호를 부여하고 윈도 단위로 전송한다.
- 패킷을 메모리에 유지하고, 모두 전송이 완료되야 메모리에서 제거한다.

### UDP

TCP와 다르게 4계층 프로토콜의 특징이 거의 없다. 헤더의 내용도 TCP에 비해 굉장히 가볍다.

UDP는 데이터 신뢰성을 보장하지 않는 프로토콜이므로 실시간성 프로토콜이나 단방향으로 다수의 단말과 통신하는 경우 사용된다. (실시간 스트리밍, 증권 시세 데이터)
이처럼 데이터를 전송하는데 신뢰성보다 시간에 맞추어 계속 전송하는 것이 중요한 서비스인 경우 사용하게 된다. UDP는 데이터가 일부 유실되더라도 그냥 유실된 상태로 데이터를 처리한다.

3 way handshake 처럼 연결을 확립하는 절차 없이 첫 데이터는 리소스 확보를 위해 인터럽트를 거는 용도로 사용되고 유실된다. 따라서 UDP를 사용하는 애플리케이션은 대부분 이런 상황을 인지하고 동작하거나 연결 확립을 위해 TCP 프로토콜을 사용해 준비를 마친 후 UDP를 이용하는 경우가 대부분이다.

**정리**

- 비연결형(3 way handshake 같은 과정 없음)
- 오류, 흐름제어를 하지 않는다.
- 실시간성 또는 단방향 통신에 주로 사용한다.

# 3.5 ARP(Address Resolution Protocol)

2계층의 MAC주소와 3계층의 IP는 아무 관계가 없는데, MAC주소를 어떻게 알아내서 통신할까? → ARP사용

첫 통신을 시도할때 IP는 있지만, MAC을 알 수 없어 패킷을 캡슐화 할 수 없다. 이때 ARP 브로드캐스트를 이용해 네트워크 전체에 상대방에 MAC 주소를 질의한다.

ARP 브로드캐스트를 받은 목적지는 자신의 MAC 주소를 응답하여 이후 패킷이 캡슐화되어 상대방에게 전달된다.

이때 받은 정보를 매번 요청하면 효율성이 저하되기 때문에 메모리에 저장해두고 재사용한다. IP는 변경될 수 있기 때문에 일정시간 통신이 없으면 삭제한다.

ARP는 CPU에서 직접 처리하기 때문에 ARP 요청이 몰리는 경우 큰 부하가 생긴다. 그렇기 때문에 ARP 공격을 하기도 하는데, ARP 요청을 필터링 하거나, 천천히 처리하도록 할 수 있다. ARP 캐시 외에도 DNS, 라우팅 캐시를 통해 네트워크 성능을 높인다.

### 동작 방법

서버에서 ping을 보낼 때 MAC을 알 수 없어 패킷을 캡슐화 할 수 없다. 이때 ARP 브로드캐스트를 이용해 네트워크 전체에 상대방에 MAC 주소를 질의한다.

출발지는 자신의 MAC 주소를, 도착지는 브로드캐스트로 채우고 ARP 프로토콜을 전송하는데, ARP 프로토콜의 대상자가 자신에 대한 요청이 맞는지 확인하고 그에대한 응답을 유니캐스트로 한다.

### GARP

일반 ARP 외에도 GARP, RARP 등의 프로토콜이 있다. 여기서 G는 Gratuitous의 약자로 대상자 IP 필드에 자신의 IP주소를 채워 요청을 보낸다.

기존의 ARP와 다른점은 자신의 IP와 MAC주소를 알릴 목적으로 사용되는 점이다.

그렇다면 왜 GARP를 사용하는걸까?

- IP 주소 충돌 감지
GARP에 대한 응답이 오면 네트워크에 동일한 IP를 사용하고 있는 것이다.
- 상대방의 ARP 테이블 갱신
액티브-스탠바이 동작하는 DB의 경우 IP는 같지만 MAC이 다른데, 스탠바이 상태의 DB가 액티브로 변할때 **변경된 MAC 주소를 알리기** 위해 사용된다.
- 고가용성 용도의 클러스터링, VRRP, HSRP
HA 솔루션의 경우처럼 이중화를 위해 사용하지만 가상 MAC을 사용하는 경우도 GARP를 사용한다. **스위치의 MAC 테이블 갱신**이 목적이다.

* DB에서 고가용성을 제공하는 경유 GARP를 여러번 보내 내부 단말의 ARP 테이블을 확실히 업데이트 하도록 해야한다. 최근엔 GARP를 가로챌 수 있어 가상 MAC을 사용하는 솔루션을 사용한다

### RARP

Reverse ARP의 뜻으로 필드값과 목적이 다르다. 현재는 BOOTP, DHCP로 대체되어 사용되지 않는다.

MAC주소를 알고, IP주소가 정해지지 않은 단말이 IP할당을 요청할 때 사용한다.

# 3.6 서브넷과 게이트웨이

게이트웨이 : 원격지 네트워크와의 통신에 사용하는 장비(라우터, L3 스위치)

### 용도

원격지 네트워크 통신은 ARP 브로드캐스트를 사용할 수 없기 때문에 게이트웨이의 도움이 필요한데, 게이트웨이에 대한 정보를 PC나 네트워크 장비에 설정하는 항목이 기본 게이트웨이다.

목적지가 동일 네트워크인지 먼저 판단해야 하는데 이때 사용하는 것이 서브넷 마스크다.

**기본 게이트웨이**

3계층 장비가 수행하는데, 여러 네트워크와 연결될 때  적절한 경로를 지정해주는 역할이다.

**프록시 ARP**

게이트웨이에 프록시 ARP가 활성화된 경우 원격지더라도 ARP 프로드캐스트를 보낼 수 있다. (장애 발생 위험이 있다.)

### 2계층 VS 3계층

2계층 통신 : 단말간 연결해주는 네트워크 장비에서 2계층까지만 정보를 확인해 통신하고 ARP 요청을 보낼때

3계층 통신 : 원격지 네트워크와 통신해야 할 경우, 해당 패킷을 전송하는 네트워크 장비에서 3계층까지 확인할 때

2계층과 3계층으로 나뉘는 기준은 출발지와 도착지의 네트워크가 같은지 유무에 따라 다른데 이는 ARP동작이 다르기 때문이다.
4계층에선 시퀀스 번호와 ACK 번호를 동일 계층에서 사용하는 정보로 사용하고, 포트 번호로 상위 프로토콜을 결정한다. 

2,3 계층에선 출발지와 도착지를 구분하지 않고 한 개만 사용했지만, 4계층의 포트 번호는 출발지와 목적지를 구분해 처리한다.(클라이언트-서버 방식)

따라서 요청에서 출발지 포트와 목적지 포트가 응답에서 반대가 된다. 이는 서비스 흐름을 이해하는데 매우 중요하다.

### TCP

TCP는 신뢰할 수 없는 공용망에서 정보 유실 없는 통신을 보장하기 위해 **세션을 안전하게 연결**하고 분할된 **패킷이 잘 전송되었는지 확인**한다.

패킷에 Sequence를 부여해 전송 여부를 응답받고, 전송 크기까지 고려한다.

분할된 패킷에 순서를 부여하고 ACK 라는 응답 번호를 통해 통신간에 패킷의 순서가 바뀌거나 손실 여부를 파악할 수 있다.

**윈도 사이즈와 슬라이딩 윈도**

패킷이 잘 전송되었는지 확인하기 위해 ACK를 받는 것 자체가 왕복 지연시간을 늘리기 때문에 여러 패킷을 한번에 보내고 응답을 하나만 받는다. 

한 번에 모든 패킷을 전송하면 좋겠지만, 네트워크 상태에 따라서 유실될 수 있기 때문에 적절한 송신량을 결정해야 하는데 이를 “윈도 사이즈”라고 하며 이 크기를 조절하는 것을 슬라이딩 윈도라고 한다.

데이터 유실이 생기면 윈도 사이즈를 절반으로 떨어트리고, 정상적으로 통신이 되면 사이즈를 하나씩 늘린다. 

윈도 사이즈는 2^16으로 64K까지 표현이 가능한데 shift 연산을 통해 그 이상의 크기 통신도 가능하다.

**3 way handshake**

TCP에서 유실없는 안전한 통신을 위해 통신 시작전 사전 연결작업을 진행한다.

1. 클라이언트에서 통신을 시도할 때 Syn 패킷을 보낸다.
2. 서버는 Syn, Ack로 응답한다.
3. 클라이언트가 Ack를 보내고 성공적으로 연결이 된다.

기존 통신과 다른점은 새로운 연결인지, 기존 통신인지 구분하기위해 헤더에 플래그값을 넣는다는 점이다.

* 4 way handshake

3 way handshake가 세션을 초기화 하기 위해 사용하는 것이면, 4 way handshake는 세션을 종료할 때 사용한다.

1. 클라이언트에서 Fin 플래그를 전송한다.
2. 서버는 Ack를 보내고 통신이 끝날때까지 기다린다.
3. 서버가 연결을 종료할 준비가 되면 Fin 플래그를 전송한다.
4. 클라이언트도 Ack 를 반환하고 세션을 종료한다.

**TCP 헤더**

- SYN - 연결 시작 용도로 사용한다.
- ACK - ACK 번호가 유효할 경우 사용한다. (SYN이 아닌이상 항상 1)
- FIN - 정상적으로 연결 종료시 1로 표시한다.
- RST - 연결 강제 종료시 사용한다.
- URG - 긴급 데이터인 경우 사용한다.
- PSH - 서버측에서 전송할 데이터가 없거나, 버퍼링없이 응용프로그램으로 즉시 전달할때 사용한다.

**정리**

- 통신 시작을 위해 3 way handshake를 통해 연결을 초기화한다.
- 패킷에 번호를 부여하고 윈도 단위로 전송한다.
- 패킷을 메모리에 유지하고, 모두 전송이 완료되야 메모리에서 제거한다.

### UDP

TCP와 다르게 4계층 프로토콜의 특징이 거의 없다. 헤더의 내용도 TCP에 비해 굉장히 가볍다.

UDP는 데이터 신뢰성을 보장하지 않는 프로토콜이므로 실시간성 프로토콜이나 단방향으로 다수의 단말과 통신하는 경우 사용된다. (실시간 스트리밍, 증권 시세 데이터)
이처럼 데이터를 전송하는데 신뢰성보다 시간에 맞추어 계속 전송하는 것이 중요한 서비스인 경우 사용하게 된다. UDP는 데이터가 일부 유실되더라도 그냥 유실된 상태로 데이터를 처리한다.

3 way handshake 처럼 연결을 확립하는 절차 없이 첫 데이터는 리소스 확보를 위해 인터럽트를 거는 용도로 사용되고 유실된다. 따라서 UDP를 사용하는 애플리케이션은 대부분 이런 상황을 인지하고 동작하거나 연결 확립을 위해 TCP 프로토콜을 사용해 준비를 마친 후 UDP를 이용하는 경우가 대부분이다.

**정리**

- 비연결형(3 way handshake 같은 과정 없음)
- 오류, 흐름제어를 하지 않는다.
- 실시간성 또는 단방향 통신에 주로 사용한다.

# 3.5 ARP(Address Resolution Protocol)

2계층의 MAC주소와 3계층의 IP는 아무 관계가 없는데, MAC주소를 어떻게 알아내서 통신할까? → ARP사용

첫 통신을 시도할때 IP는 있지만, MAC을 알 수 없어 패킷을 캡슐화 할 수 없다. 이때 ARP 브로드캐스트를 이용해 네트워크 전체에 상대방에 MAC 주소를 질의한다.

ARP 브로드캐스트를 받은 목적지는 자신의 MAC 주소를 응답하여 이후 패킷이 캡슐화되어 상대방에게 전달된다.

이때 받은 정보를 매번 요청하면 효율성이 저하되기 때문에 메모리에 저장해두고 재사용한다. IP는 변경될 수 있기 때문에 일정시간 통신이 없으면 삭제한다.

ARP는 CPU에서 직접 처리하기 때문에 ARP 요청이 몰리는 경우 큰 부하가 생긴다. 그렇기 때문에 ARP 공격을 하기도 하는데, ARP 요청을 필터링 하거나, 천천히 처리하도록 할 수 있다. ARP 캐시 외에도 DNS, 라우팅 캐시를 통해 네트워크 성능을 높인다.

### 동작 방법

서버에서 ping을 보낼 때 MAC을 알 수 없어 패킷을 캡슐화 할 수 없다. 이때 ARP 브로드캐스트를 이용해 네트워크 전체에 상대방에 MAC 주소를 질의한다.

출발지는 자신의 MAC 주소를, 도착지는 브로드캐스트로 채우고 ARP 프로토콜을 전송하는데, ARP 프로토콜의 대상자가 자신에 대한 요청이 맞는지 확인하고 그에대한 응답을 유니캐스트로 한다.

### GARP

일반 ARP 외에도 GARP, RARP 등의 프로토콜이 있다. 여기서 G는 Gratuitous의 약자로 대상자 IP 필드에 자신의 IP주소를 채워 요청을 보낸다.

기존의 ARP와 다른점은 자신의 IP와 MAC주소를 알릴 목적으로 사용되는 점이다.

그렇다면 왜 GARP를 사용하는걸까?

- IP 주소 충돌 감지
GARP에 대한 응답이 오면 네트워크에 동일한 IP를 사용하고 있는 것이다.
- 상대방의 ARP 테이블 갱신
액티브-스탠바이 동작하는 DB의 경우 IP는 같지만 MAC이 다른데, 스탠바이 상태의 DB가 액티브로 변할때 **변경된 MAC 주소를 알리기** 위해 사용된다.
- 고가용성 용도의 클러스터링, VRRP, HSRP
HA 솔루션의 경우처럼 이중화를 위해 사용하지만 가상 MAC을 사용하는 경우도 GARP를 사용한다. **스위치의 MAC 테이블 갱신**이 목적이다.

* DB에서 고가용성을 제공하는 경유 GARP를 여러번 보내 내부 단말의 ARP 테이블을 확실히 업데이트 하도록 해야한다. 최근엔 GARP를 가로챌 수 있어 가상 MAC을 사용하는 솔루션을 사용한다

### RARP

Reverse ARP의 뜻으로 필드값과 목적이 다르다. 현재는 BOOTP, DHCP로 대체되어 사용되지 않는다.

MAC주소를 알고, IP주소가 정해지지 않은 단말이 IP할당을 요청할 때 사용한다.

# 3.6 서브넷과 게이트웨이

게이트웨이 : 원격지 네트워크와의 통신에 사용하는 장비(라우터, L3 스위치)

### 용도

원격지 네트워크 통신은 ARP 브로드캐스트를 사용할 수 없기 때문에 게이트웨이의 도움이 필요한데, 게이트웨이에 대한 정보를 PC나 네트워크 장비에 설정하는 항목이 기본 게이트웨이다.

목적지가 동일 네트워크인지 먼저 판단해야 하는데 이때 사용하는 것이 서브넷 마스크다.

**기본 게이트웨이**

3계층 장비가 수행하는데, 여러 네트워크와 연결될 때  적절한 경로를 지정해주는 역할이다.

**프록시 ARP**

게이트웨이에 프록시 ARP가 활성화된 경우 원격지더라도 ARP 프로드캐스트를 보낼 수 있다. (장애 발생 위험이 있다.)

### 2계층 VS 3계층

2계층 통신 : 단말간 연결해주는 네트워크 장비에서 2계층까지만 정보를 확인해 통신하고 ARP 요청을 보낼때

3계층 통신 : 원격지 네트워크와 통신해야 할 경우, 해당 패킷을 전송하는 네트워크 장비에서 3계층까지 확인할 때

2계층과 3계층으로 나뉘는 기준은 출발지와 도착지의 네트워크가 같은지 유무에 따라 다른데 이는 ARP동작이 다르기 때문이다.
4계층에선 시퀀스 번호와 ACK 번호를 동일 계층에서 사용하는 정보로 사용하고, 포트 번호로 상위 프로토콜을 결정한다. 

2,3 계층에선 출발지와 도착지를 구분하지 않고 한 개만 사용했지만, 4계층의 포트 번호는 출발지와 목적지를 구분해 처리한다.(클라이언트-서버 방식)

따라서 요청에서 출발지 포트와 목적지 포트가 응답에서 반대가 된다. 이는 서비스 흐름을 이해하는데 매우 중요하다.

### TCP

TCP는 신뢰할 수 없는 공용망에서 정보 유실 없는 통신을 보장하기 위해 **세션을 안전하게 연결**하고 분할된 **패킷이 잘 전송되었는지 확인**한다.

패킷에 Sequence를 부여해 전송 여부를 응답받고, 전송 크기까지 고려한다.

분할된 패킷에 순서를 부여하고 ACK 라는 응답 번호를 통해 통신간에 패킷의 순서가 바뀌거나 손실 여부를 파악할 수 있다.

**윈도 사이즈와 슬라이딩 윈도**

패킷이 잘 전송되었는지 확인하기 위해 ACK를 받는 것 자체가 왕복 지연시간을 늘리기 때문에 여러 패킷을 한번에 보내고 응답을 하나만 받는다. 

한 번에 모든 패킷을 전송하면 좋겠지만, 네트워크 상태에 따라서 유실될 수 있기 때문에 적절한 송신량을 결정해야 하는데 이를 “윈도 사이즈”라고 하며 이 크기를 조절하는 것을 슬라이딩 윈도라고 한다.

데이터 유실이 생기면 윈도 사이즈를 절반으로 떨어트리고, 정상적으로 통신이 되면 사이즈를 하나씩 늘린다. 

윈도 사이즈는 2^16으로 64K까지 표현이 가능한데 shift 연산을 통해 그 이상의 크기 통신도 가능하다.

**3 way handshake**

TCP에서 유실없는 안전한 통신을 위해 통신 시작전 사전 연결작업을 진행한다.

1. 클라이언트에서 통신을 시도할 때 Syn 패킷을 보낸다.
2. 서버는 Syn, Ack로 응답한다.
3. 클라이언트가 Ack를 보내고 성공적으로 연결이 된다.

기존 통신과 다른점은 새로운 연결인지, 기존 통신인지 구분하기위해 헤더에 플래그값을 넣는다는 점이다.

* 4 way handshake

3 way handshake가 세션을 초기화 하기 위해 사용하는 것이면, 4 way handshake는 세션을 종료할 때 사용한다.

1. 클라이언트에서 Fin 플래그를 전송한다.
2. 서버는 Ack를 보내고 통신이 끝날때까지 기다린다.
3. 서버가 연결을 종료할 준비가 되면 Fin 플래그를 전송한다.
4. 클라이언트도 Ack 를 반환하고 세션을 종료한다.

**TCP 헤더**

- SYN - 연결 시작 용도로 사용한다.
- ACK - ACK 번호가 유효할 경우 사용한다. (SYN이 아닌이상 항상 1)
- FIN - 정상적으로 연결 종료시 1로 표시한다.
- RST - 연결 강제 종료시 사용한다.
- URG - 긴급 데이터인 경우 사용한다.
- PSH - 서버측에서 전송할 데이터가 없거나, 버퍼링없이 응용프로그램으로 즉시 전달할때 사용한다.

**정리**

- 통신 시작을 위해 3 way handshake를 통해 연결을 초기화한다.
- 패킷에 번호를 부여하고 윈도 단위로 전송한다.
- 패킷을 메모리에 유지하고, 모두 전송이 완료되야 메모리에서 제거한다.

### UDP

TCP와 다르게 4계층 프로토콜의 특징이 거의 없다. 헤더의 내용도 TCP에 비해 굉장히 가볍다.

UDP는 데이터 신뢰성을 보장하지 않는 프로토콜이므로 실시간성 프로토콜이나 단방향으로 다수의 단말과 통신하는 경우 사용된다. (실시간 스트리밍, 증권 시세 데이터)
이처럼 데이터를 전송하는데 신뢰성보다 시간에 맞추어 계속 전송하는 것이 중요한 서비스인 경우 사용하게 된다. UDP는 데이터가 일부 유실되더라도 그냥 유실된 상태로 데이터를 처리한다.

3 way handshake 처럼 연결을 확립하는 절차 없이 첫 데이터는 리소스 확보를 위해 인터럽트를 거는 용도로 사용되고 유실된다. 따라서 UDP를 사용하는 애플리케이션은 대부분 이런 상황을 인지하고 동작하거나 연결 확립을 위해 TCP 프로토콜을 사용해 준비를 마친 후 UDP를 이용하는 경우가 대부분이다.

**정리**

- 비연결형(3 way handshake 같은 과정 없음)
- 오류, 흐름제어를 하지 않는다.
- 실시간성 또는 단방향 통신에 주로 사용한다.

# 3.5 ARP(Address Resolution Protocol)

2계층의 MAC주소와 3계층의 IP는 아무 관계가 없는데, MAC주소를 어떻게 알아내서 통신할까? → ARP사용

첫 통신을 시도할때 IP는 있지만, MAC을 알 수 없어 패킷을 캡슐화 할 수 없다. 이때 ARP 브로드캐스트를 이용해 네트워크 전체에 상대방에 MAC 주소를 질의한다.

ARP 브로드캐스트를 받은 목적지는 자신의 MAC 주소를 응답하여 이후 패킷이 캡슐화되어 상대방에게 전달된다.

이때 받은 정보를 매번 요청하면 효율성이 저하되기 때문에 메모리에 저장해두고 재사용한다. IP는 변경될 수 있기 때문에 일정시간 통신이 없으면 삭제한다.

ARP는 CPU에서 직접 처리하기 때문에 ARP 요청이 몰리는 경우 큰 부하가 생긴다. 그렇기 때문에 ARP 공격을 하기도 하는데, ARP 요청을 필터링 하거나, 천천히 처리하도록 할 수 있다. ARP 캐시 외에도 DNS, 라우팅 캐시를 통해 네트워크 성능을 높인다.

### 동작 방법

서버에서 ping을 보낼 때 MAC을 알 수 없어 패킷을 캡슐화 할 수 없다. 이때 ARP 브로드캐스트를 이용해 네트워크 전체에 상대방에 MAC 주소를 질의한다.

출발지는 자신의 MAC 주소를, 도착지는 브로드캐스트로 채우고 ARP 프로토콜을 전송하는데, ARP 프로토콜의 대상자가 자신에 대한 요청이 맞는지 확인하고 그에대한 응답을 유니캐스트로 한다.

### GARP

일반 ARP 외에도 GARP, RARP 등의 프로토콜이 있다. 여기서 G는 Gratuitous의 약자로 대상자 IP 필드에 자신의 IP주소를 채워 요청을 보낸다.

기존의 ARP와 다른점은 자신의 IP와 MAC주소를 알릴 목적으로 사용되는 점이다.

그렇다면 왜 GARP를 사용하는걸까?

- IP 주소 충돌 감지
GARP에 대한 응답이 오면 네트워크에 동일한 IP를 사용하고 있는 것이다.
- 상대방의 ARP 테이블 갱신
액티브-스탠바이 동작하는 DB의 경우 IP는 같지만 MAC이 다른데, 스탠바이 상태의 DB가 액티브로 변할때 **변경된 MAC 주소를 알리기** 위해 사용된다.
- 고가용성 용도의 클러스터링, VRRP, HSRP
HA 솔루션의 경우처럼 이중화를 위해 사용하지만 가상 MAC을 사용하는 경우도 GARP를 사용한다. **스위치의 MAC 테이블 갱신**이 목적이다.

* DB에서 고가용성을 제공하는 경유 GARP를 여러번 보내 내부 단말의 ARP 테이블을 확실히 업데이트 하도록 해야한다. 최근엔 GARP를 가로챌 수 있어 가상 MAC을 사용하는 솔루션을 사용한다

### RARP

Reverse ARP의 뜻으로 필드값과 목적이 다르다. 현재는 BOOTP, DHCP로 대체되어 사용되지 않는다.

MAC주소를 알고, IP주소가 정해지지 않은 단말이 IP할당을 요청할 때 사용한다.

# 3.6 서브넷과 게이트웨이

게이트웨이 : 원격지 네트워크와의 통신에 사용하는 장비(라우터, L3 스위치)

### 용도

원격지 네트워크 통신은 ARP 브로드캐스트를 사용할 수 없기 때문에 게이트웨이의 도움이 필요한데, 게이트웨이에 대한 정보를 PC나 네트워크 장비에 설정하는 항목이 기본 게이트웨이다.

목적지가 동일 네트워크인지 먼저 판단해야 하는데 이때 사용하는 것이 서브넷 마스크다.

**기본 게이트웨이**

3계층 장비가 수행하는데, 여러 네트워크와 연결될 때  적절한 경로를 지정해주는 역할이다.

**프록시 ARP**

게이트웨이에 프록시 ARP가 활성화된 경우 원격지더라도 ARP 프로드캐스트를 보낼 수 있다. (장애 발생 위험이 있다.)

### 2계층 VS 3계층

2계층 통신 : 단말간 연결해주는 네트워크 장비에서 2계층까지만 정보를 확인해 통신하고 ARP 요청을 보낼때

3계층 통신 : 원격지 네트워크와 통신해야 할 경우, 해당 패킷을 전송하는 네트워크 장비에서 3계층까지 확인할 때

2계층과 3계층으로 나뉘는 기준은 출발지와 도착지의 네트워크가 같은지 유무에 따라 다른데 이는 ARP동작이 다르기 때문이다.
